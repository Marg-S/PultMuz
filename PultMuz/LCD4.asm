;LCD Define
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Настройка
; Здесь необходимо указать порты данных и управления, соответственно подключению вашего LCD
.equ	DATA_PORT = PORTB	; LCD Data Port
.equ	DATA_PIN = PINB
.equ	DATA_DDR = DDRB

.equ	CMD_PORT = PORTB	; LCD Control Port (командный порт)
.equ	CMD_PIN = PINB
.equ	CMD_DDR = DDRB

; Здесь необходимо указать номера пинов командного порта, соответственно вашему подключению
.equ	E = 0		; РВ0 -> E (РВ0 подключен к пину E)
.equ	RW = 1		; PB1 -> RW
.equ	RS = 2		; РВ2 -> RS

.equ	SPEED = 14	; выберите коэф-т задержки (14:XTAL=16MHz,10:8MHz,6:4MHz,5:<4)
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;Ожидание флага занятости контроллера дисплея
;==========================================================
BusyWait:	cli				; Запрет прерываний
	rcall	PortIn			; Порты на вход
		
	cbi	CMD_PORT,RS		; Идет Команда!
	sbi	CMD_PORT,RW		; Чтение!

BusyLoop:	sbi		CMD_PORT,E		; E=1	
	rcall	LCD_Delay		; Подождать	
			
	in	R16,DATA_PIN	; Считать байт
	push	R16				; Сохранить его в стек

	cbi	CMD_PORT,E		; E=0 (старший полубайт)	
	rcall	LCD_Delay		; Подождем маленько	

	sbi	CMD_PORT,E		; E=1	
	rcall	LCD_Delay		; Подождем
			
	cbi	CMD_PORT,E		; E=0 (второй полубайт)
	rcall	LCD_Delay		; Задержка снова	

	pop	R16				; Восстанавливаем флаг из стека
	andi	R16,0x80		; Обнуляем все биты, кроме флага
	brne	BusyLoop		; Если флаг не 0, то переход

BusyNo:	sei						; Разрешаем прерывания
	ret

;Запись команды в дисплей. Команда берется из R17
;==========================================================
CMD_WR:	cli						; Запрет прерываний
	rcall	BusyWait		; Ждем готовности

	cbi	CMD_PORT,RS		; Идет команда!
	rjmp	WR_END			; Переход на запись

;Запись данных в дисплей. Данные берутся из R17
;==========================================================
DATA_WR:	cli						; Запрет прерываний
	rcall	BusyWait		; Ждем готовности
			
	sbi	CMD_PORT,RS		; Идут данные!
WR_END:	cbi		CMD_PORT,RW		; Запись!	
	sbi	CMD_PORT,E		; E=1	
			
	rcall	PortOut			; Порт настроить на выход!
	push	R17				; Сохраним R17 в стеке
	andi	R17,0xF0		; Обнуляем младшую тетраду

	in	R16,DATA_PORT	; Значение из порта данных в R16
	andi	R16,0x0F		; Отдавим ему старшую тетраду
	push	R16				; Сохраним результат в стеке

	or	R16,R17			; Заменяем старшую тетраду
	out	DATA_PORT,R16	; Полученное значение в порт

	rcall	LCD_Delay		; Подождем	
	cbi	CMD_PORT,E		; E=0 - данные ушли в индикатор	

	rcall	LCD_Delay		; Подождем	 
	sbi	CMD_PORT,E		; E=1	
	pop	R16				; Из стека в R16 младшую тетраду
	pop	R17				; Выводимые данные в R17

	swap	R17				; Переставляем байты данных
	andi	R17,0xF0		; Отдавим младшую тетраду

	or	R16,R17			; Подставляем младшую тетраду
	out	DATA_PORT,R16	; Выдадим в порт

	rcall	LCD_Delay		; Подождем	
	cbi	CMD_Port,E		; E=0	

	rcall	PortIn			; Порт обратно на вход
	sei						; Разрешим прерывания
	ret						; Возврат

;Настройка порта данных на вход
;=========================================================================================
PortIn:	in	R16,DATA_DDR	; Данные из DDR в регистр
	andi	R16,0x0F		; Отдавливаем старшую тетраду - нам нужно сохранить младшую и обнулить старшую
	out	DATA_DDR,R16	; Выдаем результат в порт.

	in	R16,DATA_PORT	; Берем данные из порта 
	ori	R16,0xF0		; Выставляем все биты старшей тетрады, не трогая младшую
	out	DATA_PORT,R16	; Выдаем в порт
	ret

;Настройка порта данных на выход
;=========================================================================================	
PortOut:	in	R16,DATA_DDR	; Данные из ДДР в регистр
	ori	R16,0xF0		; Выставляем все биты старшей тетрады, не трогая младшую
	out		DATA_DDR,R16	; Выдаем данные в порт
	ret

;Задержка на несколько тактов
;=========================================================================================	
LCD_Delay:	ldi	R16,SPEED
L_loop:	dec	R16
	brne	L_loop
	ret
