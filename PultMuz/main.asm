;##########################################################
;##                                                      ##
;##       Музыкальная шкатулка, управляемая пультом      ##
;##                (MK ATtiny2313A, 4 МГц)               ##
;##  (PD6-приёмник TSOP, PB3-динамик через транзистор)   ##
;##  (LCD 1602A, PB4-PB7-LCD Data, PB0-PB2-LCD Control)  ##
;##                                                      ##
;##########################################################

.include "tn2313adef.inc"	; Присоединение файла описаний
.include "LCD4_macro.inc"	; Файл макросов работы с дисплеем 

.list				; Включение листинга

.def	LastIcpLow = R0		; Предыдущее значение захвата, мл.байт
.def	LastIcpHigh = R1	; Предыдущее значение захвата, ст.байт
.def	NewIcpLow = R2		; Предыдущее значение захвата, мл.байт
.def	NewIcpHigh = R3		; Предыдущее значение захвата, ст.байт

.def	temp = R16		; Вспомогательный регистр
.def	temp1 = R17		; Второй вспомогательный регистр

.def	count = R18		; Определение регистра-счетчика

.def	fnota = R19		; Частота текущей ноты
.def	dnota = R20		; Длительность текущей ноты
.def	loop = R21		; Ячейка для процедуры задержки

.def	flag = R22		; Флаговый регистр
.def	addr = R23		; Код адреса пульта
.def	comm = R24		; Код команды пульта

.equ	F_CAPTURE = 1		; Флаг прихода импульса
.equ	F_RECEIVE = 2		; Флаг завершения приёма сигнала
.equ	F_RECEIVE_OK = 3	; Флаг завершения обработки сигнала

.equ	BIT_LINE = 0x2c		; 0x2c00=11264(*0,25=2816мкс) порог определения бита (0,25мкс импульс Т1)
				; для пульта Supra: логический "0"=2мс, логический "1"=3мс
.equ	ST_MIN = 0x59		; 0x5900=22784(*0,25=5696мкс) минимум стартовой посылки
.equ	ST_MAX = 0x66		; 0x66ff=26367(*0,25=6592мкс) максимум стартовой посылки
				; длина стартовой посылки пульта  Supra = 6мс
.equ	ADDRESS = 0b00000010	; Код адреса пульта

;Резервирование ячеек памяти ОЗУ
;==========================================================
	.dseg			; Выбираем сегмент ОЗУ
	.org	0x60		; Устанавливаем текущий адрес сегмента
LastI:	.byte	2		; Предыдущее значение регистра захвата
NewI:	.byte	2		; Новое значение регистра захвата

;Начало программного кода
;==========================================================
	.cseg 			; Выбор сегмента программного кода
	.org	0		; Установка текущего адреса на ноль

start:	rjmp	init		; Переход на начало программы
	reti			; Внешнее прерывание 0
	reti			; Внешнее прерывание 1
	rjmp	prer1		; Прерывание по захвату таймера T1
	reti			; Прерывание по совпадению T1
	reti			; Прерывание по переполнению T1
	reti			; Прерывание по переполнению T0
	reti			; Прерывание UART прием завершен
	reti			; Прерывание UART регистр данных пуст
	reti			; Прерывание UART передача завершена
	reti			; Прерывание по компаратору
	reti			; Прерывание по изменению на любом контакте
	reti			; Таймер/счетчик 1. Совпадение B 
	reti			; Таймер/счетчик 0. Совпадение B 
	reti			; Таймер/счетчик 0. Совпадение A 
	reti			; USI Стартовая готовность
	reti			; USI Переполнение
	reti			; EEPROM Готовность
	reti			; Переполнение охранного таймера

;Модуль инициализации
;==========================================================

;Инициализация стека
init:	ldi	temp, RAMEND		; Выбор адреса вершины стека 
	out	SPL, temp		; Запись его в регистр стека

;Инициализация портов В/В
	clr	temp			; Инициализация порта PB
	out	PORTB, temp		; Все разряды PB = 0
	ldi	temp, 0xFF		; temp=0xFF
	out	DDRB, temp		; Все разряды PB на вывод

	ldi 	temp, 0x7F		; Инициализация порта PD
	out	PORTD, temp		; Включаем внутренние резисторы
	clr	temp			; Обнуляем temp
	out	DDRD, temp		; Порт PD на ввод

;Инициализация (выключение) компаратора
	ldi	temp, 0x80
	out	ACSR, temp

;Инициализация таймера T1
	ldi	temp, 0x09		; Включаем режим CTC, без предделителя
	out	TCCR1B, temp
	clr	temp			; Выключаем звук
	out	TCCR1A, temp

	ldi	temp,0b00001000		; Определение маски прерываний
	out	TIMSK, temp		; Разрешаем прерывание по захвату

	ldi	temp, 0xFF
	out	OCR1AH, temp		; Устанавливаем на максимум
	out	OCR1AL, temp		; регистр совпадения

;Инициализация переменных
	clr	flag			; Сброс флага в 0
	clr	dnota			; Минимальная задержка
	clr	LastIcpLow		; Обнуление значений захвата
	clr	LastIcpHigh		; мл. и ст. байтов
	clt				; Флаг Т=0, состояние КА - ожидание

;Инициализация дисплея
	rcall	wait			; Пауза для загрузки дисплея
	INIT_LCD			; Инициализация дисплея
	rcall	newCharRus		; Запись русских символов в дисплей
	
	WR_DDADR 1			; Указатель на 1-ю строку
	ldi	ZH, high(str1*2)	; Загрузка адреса символов
	ldi	ZL, low(str1*2)		; 1-й строки в регистр Z
	rcall	printString		; Вывод строки на дисплей

	WR_DDADR 0x43			; Указатель на 2-ю строку
	ldi	ZH, high(str2*2)	; Загрузка адреса символов
	ldi	ZL, low(str2*2)		; 2-й строки в регистр Z
	rcall	printString		; Вывод строки на дисплей

;Начало основной программы
;==========================================================
main:	sei				; Разрешаем все прерывания
	rcall	handle			; Подпрограмма приёма сигнала
	rcall	signal			; Подпрограмма обработки сигнала
	rcall	muz			; Подпрограмма воспроизведения мелодии
	rjmp	main			; Завершение цикла

;Приём сигнала
;==========================================================
handle:	push	temp			; Сохраняем в стеке регистры
	push	temp1

	cpi	flag, F_CAPTURE		; Поступил импульс?
	brne	h_exit			; Если нет, выходим

	clr	flag			; Иначе сбрасываем флаг

;Проверка предыдущего значения захвата на 0
	clr	temp			; Обнуляем temp
	cp	LastIcpHigh,temp	; Старший байт старого захвата=0?
	brne	h1			; Если нет, идём на сравнение
	cp	LastIcpLow,temp		; Если младший байт=0,
	breq	h_save			; выход с сохранением значений захвата

;Сравнение предыдущего и нового значений захвата
h1:	cp	LastIcpHigh,NewIcpHigh	; Старый или новый захват больше?
	brne	h2			; Если старшие байты захватов равны,
	cp	LastIcpLow,NewIcpLow	; сравниваем младшие байты
h2:	brsh	h3			; Если старый захват больше, на h3

;Вычисление периода импульса
	mov	temp1,NewIcpLow		; Сохраняем копию нового захвата
	mov	temp,NewIcpHigh		; Мл.байт - в temp1, ст.байт - в temp
	sub	temp1, LastIcpLow	; Из нового вычитаем старое значение
	sbc	temp, LastIcpHigh	; Period=New-Last
	rjmp	h4

h3:	ldi	temp1, 0xFF		; temp1=0xFF
	ldi	temp, 0xFF		; temp=0xFF
	sub	temp1, LastIcpLow	; temp=0xFF-Last
	sub	temp, LastIcpHigh
	add	temp1, NewIcpLow
	adc	temp, NewIcpHigh	; PeriodHigh=New+(FF-Last)

h4:	brts	h_recv			; Если Т=1, КА-приём, идём на обработку

;Состояние конечного автомата - ожидание стартовой посылки
h_idle:	cpi	temp, ST_MIN		; Сравниваем время импульса с минимумом
	brlo	h_clr			; Если меньше, то выходим

	cpi	temp, ST_MAX		; Сравниваем время импульса с максимумом
	brsh	h_clr			; Если больше, то выходим

	set				; Ставим Т=1, пришла стартовая посылка
	ldi	count, 16		; Состояние КА - приём, count=16
	rjmp	h_save			; Выход с сохранением значений захвата

;Состояние конечного автомата - приём импульсов, формирование сигнала
h_recv:	cpi	count, 0		; Код команды записан?
	brne	h_byte			; Если нет, продолжаем считывать байт

	ldi	flag, F_RECEIVE		; Иначе выставляем флаг завершения приёма
	clt				; Ставим Т=0, состояние КА - ожидание
	rjmp	h_clr			; И выход с обнулением значений захвата

;Считываем байт
h_byte:	lsl	comm			; Сдвигаем биты команды
	cpi	temp, BIT_LINE		; Сравниваем импульс с порогом
	brlo	h_0			; Если меньше, бит команды = 0
	sbr	comm, 0b00000001	; Иначе бит команды = 1
	rjmp	h_end			; Завершили определение бита
h_0:	cbr	comm, 0b00000001	; Обнуляем младший бит команды

h_end:	dec	count			; Уменьшаем на 1 количество бит
	cpi	count, 8		; Код адреса пульта записан?
	brne	h_save			; Если нет, выход с сохранением захватов
	mov	addr, comm		; Сохраняем считанный байт в addr
	rjmp	h_save			; Выход с сохранением значений захвата

h_clr:	clr	NewIcpLow		; Обнуляем значения захвата
	clr	NewIcpHigh

h_save:	mov	LastIcpLow,NewIcpLow	; Сохраняем новые значения захвата
	mov	LastIcpHigh,NewIcpHigh

h_exit:	pop	temp1			; Восстанавливаем регистры
	pop	temp
	ret

;Обработка сигнала
;==========================================================
signal:	cpi	flag, F_RECEIVE		; Принят сигнал?
	brne	s_exit			; Если нет, выход

	clr	flag			; Сбрасываем флаг
	rcall	printCod		; Выводим на дисплей код сигнала пульта

	cpi	addr, ADDRESS		; Получен нужный адрес пульта?
	brne	s_exit			; Нет, выход

	cpi	comm, 10		; На пульте нажата кнопка с цифрой?
	brsh	s_exit			; Нет, выход

	ldi	flag, F_RECEIVE_OK	; Сигнал обработан
	cpi	comm, 9			; Нажата 9? 
	brne	s_exit			; Нет, пропуск след.шага
	ldi	comm, 3			; Да, выбираем песню №3

s_exit:	ret

;Выбор мелодии
;==========================================================
muz:	push	temp			; Сохраняем регистр temp в стек
	cpi	flag, F_RECEIVE_OK	; Сигнал обработан?
	brne	m_exit			; Если нет, выход

	clr	flag			; 
	dec	comm			; Уменьшаем comm на 1
	brmi	m_exit

	mov	YL, comm		; Вычисляем адрес, где
	ldi	ZL, low(tabm*2)		; хранится начало мелодии
	ldi	ZH, high(tabm*2)
	rcall	addw			; К подпрограмме 16-разрядного сложения

	lpm	XL, Z+			; Извлекаем адреса из таблицы
	lpm	XH, Z			; и помещаем в X

;Воспроизведение мелодии
m_1:	mov	ZH, XH			; Записываем в Z начало мелодии
	mov	ZL, XL

m_2:	lpm	temp, Z			; Извлекаем код ноты
	cpi	temp, 0xFF		; Проверяем не конец ли мелодии
	breq	m_1			; Если конец, начинаем мелодию сначала

	andi	temp, 0x1F		; Отделяем от кода частоту
	mov	fnota, temp		; Записываем в регистр частоту ноты
	lpm	temp, Z+		; Еще раз берем код ноты
	rol	temp			; Сдвигаем так, что бы три старших
	rol	temp			; разряда стали младшими
	rol	temp
	rol	temp
	andi	temp, 0x07		; Извлекаем код длительности задержки
	mov	dnota, temp		; Помещаеем ее в ячейку длительности

	rcall	nota			; К подпрограмме воспроизведения ноты
	cpi	flag, F_RECEIVE_OK	; Поступила новая команда?
	brne	m_2			; Нет, в начало цикла (следующая нота)

m_exit:	pop	temp			; Восстанавливаем регистр temp из стека
	ret

;Подпрограмма 16-ти разрядного сложения
;==========================================================
addw:	push	YH
	lsl	YL			; Умножение первого слагаемого на 2
	ldi	YH, 0			; Второй байт первого слагаемого = 0
	add	ZL, YL			; Складываем два слагаемых
	adc	ZH, YH
	pop	YH
	ret

;Подпрограмма исполнения одной ноты
;==========================================================
nota:	push	ZH			; Сохраняем регистры в стек
	push	ZL
	push	YL
	push	temp
	push	temp1

	cpi	fnota, 0		; Проверка не пауза ли
	breq	nt1			; Если пауза, переходим сразу к задержке

	mov	YL, fnota		; Вычисляем адрес, где хранится
	ldi	ZL, low(tabkd*2)	; коэффициент деления для текущей ноты
	ldi	ZH, high(tabkd*2)
	rcall	addw			; К подпрограмме 16-разрядного сложения

	lpm	temp, Z+		; Извлекаем мл.разряд КД для текущей ноты
	lpm	temp1, Z		; Извлекаем ст.разряд КД для текущей ноты
	out	OCR1AH, temp1		; Записать в ст.часть регистра совпадения
	out	OCR1AL, temp		; Записать в мл.часть регистра совпадения

	ldi	temp, 0x40		; Включить звук
	out	TCCR1A, temp

nt1:	rcall	wait			; Задержка

	ldi	temp, 0			; Выключить звук
	out	TCCR1A, temp

	ldi	dnota,0			; Сбрасываем задержку 
	rcall	wait			; Пауза между нотами

	pop	temp1			; Восстанавливаем регистры из стека
	pop	temp
	pop	YL
	pop	ZL
	pop 	ZH
	ret

;Подпрограмма задержки
;==========================================================
wait:	push	ZH			; Сохраняем регистры в стек
	push	ZL
	push	YH
	push	YL

	mov	YL, dnota		; Вычисляем адрес, где хранится
	ldi	ZL, low(tabz*2)		; нужный коэффициент задержки
	ldi	ZH, high(tabz*2)
	rcall	addw			; К подпрограмме 16-разрядного сложения

	lpm	YL, Z+			; Читаем первый байт коэффициента задержки
	lpm	YH, Z			; Читаем второй байт коэффициента задержки

w0:	clr	ZL			; Обнуляем регистровую пару Z
	clr	ZH

w1:	ldi	loop,255		; Цикл задержки
w2:	dec	loop			; Пустой внутренний цикл
	brne 	w2

	cpi	flag, F_CAPTURE		; Поступил импульс?
	brne	w_1			; Если нет, продолжаем

	ldi	temp, 0			; Если да, выключить звук
	out	TCCR1A, temp
	rcall	handle			; К подпрограмме приёма
	brts	w0			; Если Т=1, КА-приём, пауза

w_1:	cpi	flag, F_RECEIVE		; Поступил сигнал?
	brne	w_2			; Если нет, продолжаем
	rcall	signal			; К подпрограмме обработки

w_2:	cpi	flag, F_RECEIVE_OK	; Сигнал обработан?
	breq w3				; Если да, выходим

	adiw	R30, 1			; Увеличение регистровой пары Z на единицу
	cp	YL, ZL			; Проверка младшего разряда
	brne	w1
	cp	YH, ZH			; Проверка старшего разряда
	brne	w1

w3:	pop	YL			; Восстанавливаем регистры из стека
	pop	YH
	pop	ZL
	pop 	ZH
	ret				; Завершение подпрограммы

.include "LCD4.asm"			; Присоединение библиотеки

;Запись новых (русских) символов в знакогенератор
;==========================================================
newCharRus:
	WR_CGADR 0			; Указатель на начало знакогенератора
	WR_DATA 0b00010101		; Ж
	WR_DATA 0b00010101
	WR_DATA 0b00010101
	WR_DATA 0b00001110
	WR_DATA 0b00010101
	WR_DATA 0b00010101
	WR_DATA 0b00010101
 	WR_DATA 0b00000000

	WR_CGADR 8			; 1
	WR_DATA 0b00010001		; И
	WR_DATA 0b00010001
	WR_DATA 0b00010011
	WR_DATA 0b00010101
	WR_DATA 0b00011001
	WR_DATA 0b00010001
	WR_DATA 0b00010001
	WR_DATA 0b00000000

	WR_CGADR 16			; 2
	WR_DATA 0b00011111		; П
	WR_DATA 0b00010001
	WR_DATA 0b00010001
 	WR_DATA 0b00010001
	WR_DATA 0b00010001
 	WR_DATA 0b00010001
	WR_DATA 0b00010001
	WR_DATA 0b00000000

	WR_CGADR 24			; 3
	WR_DATA 0b00010001		; У
	WR_DATA 0b00010001
	WR_DATA 0b00010001
 	WR_DATA 0b00001010
	WR_DATA 0b00000100
 	WR_DATA 0b00001000
	WR_DATA 0b00010000
	WR_DATA 0b00000000

	WR_CGADR 32			; 4
	WR_DATA 0b00001111		; Л
	WR_DATA 0b00000101
 	WR_DATA 0b00000101
	WR_DATA 0b00000101
 	WR_DATA 0b00000101
	WR_DATA 0b00010101
	WR_DATA 0b00001001
	WR_DATA 0b00000000

	WR_CGADR 40			; 5
	WR_DATA 0b00010001		; Ц
	WR_DATA 0b00010001
 	WR_DATA 0b00010001
	WR_DATA 0b00010001
 	WR_DATA 0b00010001
	WR_DATA 0b00010001
	WR_DATA 0b00011111
	WR_DATA 0b00000001

	WR_CGADR 48			; 6
	WR_DATA 0b00000100		; Ф
	WR_DATA 0b00001110
 	WR_DATA 0b00010101
	WR_DATA 0b00010101
 	WR_DATA 0b00010101
	WR_DATA 0b00001110
	WR_DATA 0b00000100
	WR_DATA 0b00000000
	
	ret

;Вывод строки из программной памяти на дисплей (адрес в Z)
;==========================================================
printString:
ps_1:	lpm	temp1, Z+		; Считываем символ в temp1
	cpi	temp1, 0xFF		; Конец строки?
	breq	ps_exit			; Если да, выходим
	rcall	DATA_WR			; Иначе выводим символ из R17 на дисплей
	rjmp	ps_1			; Идём на следующий символ
ps_exit:	ret

;Вывод на дисплей кодов адреса и команды пульта
;==========================================================
printCod:
	LCDCLR				; Очистить экран
	WR_DDADR 0			; Вывод на дисплей адреса и команды
	WR_DATA 0x4B			; K
	WR_DATA 0x6F			; o
	WR_DATA 0x67			; g
	WR_DATA 0x3A			; :
	WR_DATA 0x20			; Пробел

	mov	temp1, addr		; Сохраняем addr в регистр temp1
	rcall	printValue		; К подпрограмме вывода 2-зн. числа
	mov	temp1, comm		; Сохраняем comm в регистр temp1
	rcall	printValue		; К подпрограмме вывода 2-зн. числа

	ret

;Вывод на экран двузначного значения из temp1
;==========================================================
printValue:
	clr	temp			; Обнуляем temp
s1:	cpi	temp1, 10		; temp1 >= 10 ?
	brlo	s2			; Если нет, идём на печать

	inc	temp			; Иначе temp++
	subi	temp1, 10		; temp1 - 10
	rjmp	s1			; Идём на проверку temp1

s2:	cpi	temp, 0			; temp=0? 
	breq	s3			; Если да, идём на печать temp1
	push	temp1			; Иначе сохраняем temp1 в стек
	ldi	temp1, 0x30		; temp1=0x30
	add	temp1, temp		; temp1+=temp
	rcall	DATA_WR			; Печатаем символ с кодом temp1
	pop	temp1			; Восстанавливаем temp1 из стека

s3:	ldi	temp, 0x30		; temp=0х30
	add	temp1, temp		; temp1+=temp
	rcall	DATA_WR			; Печатаем символ с кодом temp1
	WR_DATA 0x20			; Пробел

	ret

;Подпрограммы обработки прерываний
;==========================================================
;Обработка прерывания по захвату значения таймера Т1
prer1:	cli				; Запрещаем все прерывания

	ldi	temp, 0xFF
	out	OCR1AH, temp		; Регистр совпадения на максимум
	out	OCR1AL, temp
		
	in	NewIcpLow, ICR1L	; Считываем значение захвата,
	in	NewIcpHigh, ICR1H	; младший и старший байты

	ldi	flag, F_CAPTURE		; Флаг - поступил импульс

	sei				; Разрешаем все прерывания
	reti

;Строки вывода на дисплей
;==========================================================
;Нажмите цифру
str1:   .db	0x48,0x41,0,0x4D,1,0x54,0x45,0x20,5,1,6,0x50,3,0xFF
;на пульте
str2:   .db	0x48,0x41,0x20,2,3,4,0x62,0x54,0x45,0xFF

;Таблица задержек
;==========================================================
tabz:   .dw	128,256,512,1024,2048,4096,8192

;Таблица коэффициентов деления
;==========================================================
tabkd:	.dw	0
	.dw	4748,4480,4228,3992,3768,3556,3356,3168,2990,2822,2664,2514
	.dw	2374,2240,2114,1996,1884,1778,1678,1584,1495,1411,1332,1257
	.dw	1187,1120,1057, 998, 942, 889, 839, 792

;Таблица начал всех мелодий
;==========================================================
tabm:	.dw	mel1*2,mel2*2,mel3*2,mel4*2
	.dw	mel5*2,mel6*2,mel7*2,mel8*2

;Таблица мелодий
;==========================================================

;В траве сидел кузнечик
mel1:	.db	109,104,109,104,109,108,108, 96,108,104 
	.db	108,104,108,109,109, 96,109,104,109,104 
	.db	109,108,108, 96,108,104,108,104,108,141 
	.db	 96,109,111, 79, 79,111,111,112, 80, 80 
	.db	112,112,112,111,109,108,109,109, 96,109 
	.db	111, 79, 79,111,111,112, 80, 80,112,112 
	.db	112,111,109,108,141,128, 96,255 

;Песенка крокодила Гены
mel2:	.db	109,110,141,102,104,105,102,109,110,141 
	.db	104,105,107,104,109,110,141,104,105,139 
	.db	109,110,173, 96,114,115,146,109,110,112 
	.db	109,114,115,146,107,109,110,114,112,110 
	.db	146,109,105,136,107,105,134,128,128,102 
	.db	105,137,136,128,104,107,139,137,128,105 
	.db	109,141,139,128,110,109,176,112,108,109 
	.db	112,144,142,128,107,110,142,141,128,105 
	.db	109,139,128,173,134,128,128,109,112,144 
	.db	142,128,107,110,142,141,128,105,109,139 
	.db	128,173,146,128, 96,255

;В лесу родилась елочка
mel3:	.db	132,141,141,139,141,137,132,132,132,141 
	.db	141,142,139,176,128,144,146,146,154,154 
	.db	153,151,149,144,153,153,151,153,181,128 
	.db	 96,255

;Happy births to you
mel4:	.db	107,107,141,139,144,143,128,107,107,141
	.db	139,146,144,128,107,107,151,148,146,112
	.db	111,149,117,117,148,144,146,144,128,255

;С чего начинается родина
mel5:	.db	 99,175,109,107,106,102, 99,144,111,175 
	.db	 96, 99,107,107,107,107,102,104,170, 96 
	.db	 99,109,109,109,109,107,106,143,109,141 
	.db	 99,109,109,109,109,104,106,171, 96, 99 
	.db	111,109,107,106,102, 99,144,111,143,104 
	.db	114,114,114,114,109,111,176, 96,104,116 
	.db	112,109,107,106, 64, 73,143,107,131, 99 
	.db	144, 80, 80,112,111, 64, 75,173,128,255

;Из кинофильма "Веселые ребята"
mel6:	.db	105,109,112,149,116, 64, 80,148,114, 64 
	.db	 78,146,112, 96,105,105,109,144,111, 64 
	.db	 80,145,112, 64, 81,178, 96,117,117,117 
	.db	149,116, 64, 82,146,112, 64, 79,146,144 
	.db	 96,105,105,107,141,108,109,112,110,102 
	.db	104,137,128, 96,105,105,105,137,102, 64 
	.db	 73,142,105,107,109, 64, 75,137, 96,105 
	.db	105,105,137,102,105,142,112, 64, 82,180 
	.db	 96,116,116,116,148,114,112,142,109, 64 
	.db	 78,146,144, 96,105,105,107,141,108,109 
	.db	112,110,102,104,169, 96, 96,255

;Улыбка
mel7:	.db	107,104,141,139,102,105,104,102,164,128 
	.db	104,107,109,109,109,111,114,112,111,109 
	.db	144,139,128,109,111,144, 96,111,109,104 
	.db	107,105,173,128,111,109,112,107,111,109 
	.db	109,107,102,104,134,132,128,100,103,107
	.db	107,107,107,139,112,100,103,102,102,102 
	.db	134,102,103,107,105,107,108,108,108,108 
	.db	107,105,107,108,144,142,128,112,107,110 
	.db	140,112,105,108,107,107,107,105,140,139 
	.db	139,112,103,102,103,105,108,107,105,103 
	.db	128,112,107,110,108,108,108,140,112,105 
	.db	108,107,107,107,139,112,103,102,103,105 
	.db	108,107,105,103,105,139,132,128, 96, 96 
	.db	 96,255

;Огонек
mel8:	.db	102,105,141,107,105,141, 96,107,171, 96 
	.db	104,105,139,104,105,166,128,160,109,110 
	.db	144,110,109,144, 96,110,174,128,110,112 
	.db	146,112,114,205,117,117,149,116,114,149
	.db	 96,116,174,128,110,112,146,112,114,205 
	.db	128,102,105,141,107,105,141, 96,107,171 
	.db	128,104,105,139,104,105,166,128,128,117 
	.db	117,149,116,114,149, 96,116,174,128,110
	.db	112,146,112,114,205,128,102,105,141,107 
	.db	105,141, 96,107,171,128,104,105,139,104
	.db	105,166,128,128, 96,255 
